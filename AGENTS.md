# AGENTS.md — Coolant_automation (Coolant Control System V2)

## 0) Назначение файла
Этот документ задаёт **строгие правила** для агента Codex при работе над проектом **Coolant_automation**:
- какие источники считаются “истиной”;
- как выглядит целевая система и её алгоритм;
- какие артефакты и в каком формате агент обязан выпускать;
- какие предположения запрещены.

Цель: чтобы агент **не “додумывал” железо/логику**, а работал воспроизводимо и проверяемо.

---

## 1) Краткое описание системы
Система автоматически доливает жидкость (эмульсию/воду) в ёмкость по двум датчикам уровня:
- при достижении **MIN** открывает клапан (через реле);
- при достижении **MAX** закрывает клапан.

Во время долива учитывает расход по импульсам **расходомера**, контролирует pH (как прокси “концентрации”), и пишет события на **SD-карту** с временными метками **RTC**.

Первичный текст описания: `Описание .docx`.

---

## 2) Источники правды и приоритеты (НЕ НАРУШАТЬ)

### 2.1 Приоритет источников
1) **BOM/спецификация компонентов**: [Coolant control System V2.xlsx](<Coolant control System V2.xlsx>)  
   Истина по: моделям, артикулам, напряжениям, типам датчиков (PNP/NO/NC), интерфейсам, ссылкам на поставщика.
2) **Описание алгоритма**: `Описание .docx`  
   Истина по: логике MIN/MAX, записи на SD, назначению pH/flow.
3) **Диаграммы проекта (.mmd)**  
   Истина по: при конфликте обязаны вернуться к п.1–2 и исправить диаграмму.
      1 [Hardware](Documentation/Coolant_Hardware_ultra.mmd)
      2 [IDLE](Documentation/Coolant_IDLE_ultra.mmd)
      3 [FILLING](Documentation/Coolant_FILLING_ultra.mmd)
      4 [FMS](Documentation/Coolant_FSM_ultra.mmd)
      5 [BOOT](Documentation/Coolant_BOOT_ultra.mmd)
      6 [ERROR](Documentation/Coolant_ERROR_ultra.mmd)

4) Любые сторонние знания/интернет/примеры — только если **нет данных в п.1–3**, и только после фиксации как “внешний источник” или запроса пользователю.

### 2.2 Разрешение конфликтов
Если `Описание .docx` упоминает один бренд/модель, а BOM другой (пример: Omron vs LANBAO):
- **BOM считается приоритетом**, а конфликт фиксируется как `OPEN_QUESTION` и выносится пользователю.

---

## 3) Жёсткие правила для агента (anti-hallucination)

### 3.1 Запрещено
- Подбирать “аналог” компонента вместо BOM.
- Заполнять пустые поля BOM предположениями (кол-во, напряжение, интерфейс, NO/NC, PNP/NPN, коэффициенты).
- Выдумывать распиновку/схему подключения без явного источника.
- Объединять несколько диаграмм Mermaid в одном `.mmd` (риск несовместимости).

### 3.2 Обязательно
- Если параметр неизвестен — пометить `NEED_USER_INPUT` и перечислить, что нужно уточнить.
- При ссылке на компонент использовать BOM-формулировку: категория/производитель/номер/ссылка.
- Любая модификация алгоритма → обновить соответствующую диаграмму `.mmd` и кратко описать изменение.

---

## 4) Mermaid-диаграммы: “ультра-совместимый” стандарт (проектный)

### 4.1 Почему
Рендереры Mermaid в IDE/плагинах часто поддерживают не все возможности. Проектный стандарт — **ультра-совместимость**.

### 4.2 Строгий профиль
- В файле `.mmd` должна быть **ровно одна** диаграмма: `flowchart TD`.
- **Без** `stateDiagram`, `sequenceDiagram`, без нескольких диаграмм в одном файле.
- **Без** сложных лейблов: без переносов строк, без HTML, без markdown-форматирования.
- Узлы: `ID[Text]` и решения `ID{Question}`.
- Избегать слова `end` в лейблах узлов (использовать `STOP`, `FINISH`, `STOP_TS`).

### 4.3 Разбиение диаграмм (один файл — один “взгляд”)
Рекомендуемая структура (в репозитории):
- `docs/diagrams/Coolant_Hardware_ultra.mmd` — hardware/topology
- `docs/diagrams/Coolant_FSM_ultra.mmd` — FSM переходы состояний
- `docs/diagrams/Coolant_BOOT_ultra.mmd` — процессы BOOT
- `docs/diagrams/Coolant_IDLE_ultra.mmd` — процессы IDLE
- `docs/diagrams/Coolant_FILLING_ultra.mmd` — процессы FILLING
- `docs/diagrams/Coolant_ERROR_ultra.mmd` — процессы ERROR

---

## 5) BOM: как использовать таблицу компонентов

### 5.1 Колонки BOM
BOM содержит колонки:
- `Kategooria` (категория)
- `Tootja` (производитель)
- `number` (модель/артикул)
- `Sisendpinge` (входное напряжение)
- `Väljundpinge` (выходное напряжение)
- `Elektrivool` (ток)
- `Kogus` (количество)
- `Hind` (цена)
- `Link` (ссылка на товар/даташит)

### 5.2 Если поле пустое
- НЕЛЬЗЯ догадаться.
- Нужно занести в `OPEN_QUESTIONS` и запросить ввод.

---

## 6) Алгоритм управления (контракт поведения)

### 6.1 События и состояния (логический каркас)
Система описывается FSM:
- `BOOT` → `IDLE` (если init OK), иначе `ERROR`
- `IDLE` → `FILLING` (MIN stable)
- `FILLING` → `IDLE` (MAX stable)
- `FILLING` → `ERROR` (timeout / критическая ошибка по политике)
- `ERROR` → `IDLE` (manual reset) или `BOOT` (power cycle)

Подробность внутренних процессов описывается отдельными диаграммами `BOOT/IDLE/FILLING/ERROR`.

### 6.2 Контроль уровня
- MIN триггер запускает цикл долива.
- MAX триггер завершает долив.
- Требуется программная фильтрация дребезга (debounce) и правило стабильности `MIN_STABLE_MS`, `MAX_STABLE_MS` (значения уточняются).

### 6.3 Расход
- Импульсы расходомера считаются (interrupt) и используются для расчёта объёма:
  - `volume = pulses / pulses_per_liter`
- `pulses_per_liter` — **NEED_USER_INPUT** (калибровка/даташит).

### 6.4 pH (концентрация)
- pH измеряется периодически и/или по окончанию цикла.
- Пороги реакции — **NEED_USER_INPUT** (только лог / сигнал / блокировка).

### 6.5 Fail-safe
- Клапан по умолчанию: `CLOSED` на старте и при ошибках.
- Таймаут долива `MAX_FILL_TIME_MS` — **NEED_USER_INPUT**.

---

## 7) Логирование на SD: формат, который обязателен

### 7.1 Принцип
Одна строка CSV = один цикл долива.

### 7.2 Рекомендуемый формат CSV (минимум)
Файл: `fill_log.csv` (в корне SD или в папке `/logs`)

Поля:
- `START_TS` (ISO 8601 или “YYYY-MM-DD HH:MM:SS” из RTC)
- `STOP_TS`
- `PULSES`
- `VOLUME_L` (литры) или `VOLUME_ML` (мл) — выбрать один стандарт
- `PH`
- `STATUS` (`OK`, `TIMEOUT`, `ERROR_INIT`, `ERROR_SD`, ...)

Примечание: не использовать поле `end_ts` (слово `end` может ломать Mermaid-рендереры; в логах можно, но для единообразия используем `STOP_TS`).

### 7.3 Ошибки записи
Политика (что делать при ошибке записи на SD) должна быть явно определена:
- `NEED_USER_INPUT`: retry? буфер в RAM? переход в ERROR?

---

## 8) Код и артефакты, которые выпускает агент

### 8.1 Firmware (Arduino/C++)
Структура (рекомендация):
- `firmware/src/main.ino` или `main.cpp`
- `firmware/src/modules/`:
  - `level_sensors.*` (debounce/logic)
  - `flow_meter.*` (interrupt counter + conversion)
  - `ph_meter.*` (sampling + calibration hooks)
  - `rtc_clock.*`
  - `sd_logger.*`
  - `valve_relay.*`
  - `fsm.*`

Требования:
- явные константы в `config.h`
- безопасное поведение: valve CLOSED при ошибках
- отсутствующие параметры помечать `NEED_USER_INPUT` прямо в коде комментариями `// NEED_USER_INPUT: ...`

### 8.2 Python-утилиты (анализ логов)
Цели:
- парсинг `fill_log.csv`
- отчёты: расход по дням/неделям/месяцам, средний pH, количество циклов
- поиск аномалий: частые доливы, рост расхода, выход pH за пороги

Рекомендованная структура:
- `tools/parse_logs.py`
- `tools/report.py`
- `tools/schema.md` (описание формата CSV)

---

## 9) Процесс работы агента (workflow)

1) Прочитать `Coolant control System V2.xlsx` и `Описание .docx`.
2) Сверить текущие диаграммы `.mmd` с документами.
3) Сформировать список `OPEN_QUESTIONS` (только то, без чего нельзя двигаться).
4) Предложить изменение/код **минимальным патчем**, с пояснением.
5) Обновить диаграммы при изменениях логики.
6) Добавить простые проверки/тесты (где возможно).

---

## 10) OPEN_QUESTIONS (шаблон)
Агент обязан поддерживать список открытых вопросов. Пример:

- Q1: Тип выходов датчиков MIN/MAX (PNP NO/NC) и логика “активного” уровня.
- Q2: Интерфейс microSD адаптера (SPI или I2C) и фактическое подключение через I2C Hub (если применимо).
- Q3: pulses_per_liter для расходомера (калибровка/даташит).
- Q4: Пороговые значения pH и политика реакции.
- Q5: MAX_FILL_TIME_MS и debounce интервалы.

---

## 11) Минимальные критерии готовности (Definition of Done)
Любая задача считается выполненной только если:
- изменения не противоречат BOM/описанию,
- отсутствующие параметры помечены `NEED_USER_INPUT`,
- код компилируется (для firmware) или запускается (для Python),
- обновлены соответствующие `.mmd` диаграммы при изменении логики,
- перечислены проверки/тест-сценарии (manual или автоматические).

